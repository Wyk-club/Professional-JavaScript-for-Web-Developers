# concept
[TOC]

## 01 文档模式
* 混杂模式
* 标准模式
* 准标准模式

准标准模式和标准模式非常接近，它们的差异几乎可以忽略不计。

一般来说，在提到标准模式时，指的是除混杂模式之外的其他模式。

## 02 noscript元素
noscript是一个元素，该元素能够包含出现在文档body中的任何HTML元素(script元素除外)。

包含在noscript元素中的内容只有在以下情况才会显示出来:
* 浏览器不支持脚本
* 浏览器支持脚本，但脚本被禁用

## 03 标识符
标识符就是指变量、函数、属性的名字，或者函数的参数。要求:
* 第一个字符必须是一个字母、下划线或一个美元符号
* 其他字符可以是字母、下划线、美元符号或数字

注意:
* 推荐使用驼峰命名法
* 关键字、保留字、true、false、null不能作为标识符

## 04 注释
单行注释
```javascript
// 单行注释

/* 
*
*
*/
```
多行注释，以/ * 开始，* /结尾，中间的*是为了代码的可读性

## 05 尽量显式地初始化变量
尽量在声明变量的时候进行赋值，尽管未初始化的变量会自动被赋予undefined值。

因为声明但是未初始化的变量或是未声明的变量同时用typeof操作符进行判断都返回undefined，所以，如果我们有良好的习惯(显式的进行声明)，当typeof操作符返回"undefined"，我们就知道被检测的变量没有被声明，而不是尚未初始化。

## 06 null == undefined结果是true
undefined的值是派生自null值的，所以，用==判断，返回true，当然，用===判断，结果返回false

## 07 Number类型
数值字面量格式可以是十进制、八进制或十六进制
* 八进制
第一位必须是0，然后是八进制数字序列(0~7)

如果字面量中的数值超出了范围，那么前导零(第一个0)将被忽略，后面的数值将被当做十进制数值解析。
* 十六进制
前两位必须是0x，后跟任何十六进制数字(0~9及A~F)，字母A~F可以大写，也可以小写

* 注意:
在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

### 001 浮点数值
浮点数值: 该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字

### 002 数值范围
* ECMAScript能表示的最大数值保存在:
**Number.MAX_VALUE**

* ECMAScript能表示的最小数值保存在:
**Number.MIN_VALUE**

* 如果得到一个超出JavaScript数值范围的值，这个数值将被自动转换成特殊的Infinity值(具体来说的话是Infinity和-Infinity)

* Infinity是不能参与计算的，如果你想判断某个数值是不是能够参与计算的，可以使用isFinite()函数，如果结果返回true，表示这个值处于最大值和最小值之间，即可以参与计算

### 003 NaN
* 任何涉及NaN的操作，都会返回NaN
* NaN与任何值都不相等，包括NaN本身
* **isNaN()** 判断某个参数是够能转化成数值
可以接收对象(对于对象，先调用对象的valueOf()方法，然后依照规则转换返回的值。如果转换的结果是NaN，则基于返回值调用对象的toString()方法，然后再次依照规则转换返回的字符串值)。 

### 004 数值转换
有3个函数可以把非数值转换为数值:
* Number()

各种数据类型 → 数值
* parseInt()

字符串 → 整数

忽略字符串前面的空格

如果字符串以"0"开头，后面跟数字字符，将作为八进制数来解析

如果字符串以"0x"开头，后面跟数字字符，将作为十六进制数来解析

接受第2个参数，即转换使用的基数(多少进制)。如果指定了进制，就不用带字符串前面的"0"或"0x"。

* parseFloat()

字符串 → 小数

始终都会忽略前导的0

只解析十进制数，不支持第二个参数指定基数

## 08 String类型
把一个值转换为一个字符串有两种方式:
* toString()

几乎所有值都有这个方法(null和undefined除外)
接受一个参数: 输出数值的基数，如果不传，默认是10进制

* String()

可以将任何类型的值转换为字符串，规则如下:
* 如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果
* 如果值是null，则返回"null"
* 如果值是undefined，则返回"undefined"

## 09 Object
Object的每个实例都具有下列属性和方法。
* constructor：保存着哦用于创建当前对象的函数
* hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中(而不是再实例的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定
* isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型
* propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
* toLocaleString()：放回对象的字符串表示，该字符串与执行环境的地区对应。
* toString()：放回对象的字符串表示。
* valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

## 10 操作符
包括：
* 算数操作符
* 位操作符
* 关系操作符
* 相等操作符

### 01 一元操作符
#### 001 递增和递减操作符
前置递增和递减操作时，变量的值都是在语句被求值之前改变的(也就是先执行递增/递减操作，再运算)

后置递增和递减操作时，变量的值都是在包含它们的语句被求值之后才执行的(也就是先运算，再执行递增/递减操作)

这四个操作符对任何值都适用，即整数、字符串、布尔值、浮点数、对象。遵从以下规则：
* 在应用于一个包含有效数字字符的字符串时，先将其转换成数字值，再执行加减1的操作。字符串变量变成数值变量。
* 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变为数值变量。
* 在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变为数值变量。
* 在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变为数值变量。
* 在应用于浮点数值时，执行加减1的操作。
* 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

#### 002 一元加和减操作符
* **一元加操作符**

在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值进行转换，即：
* 布尔值的false和true将被转换为0和1
* 字符串值会被按照一组特殊的规则进行解析
* 对象先是调用它们的valueOf()和(或)toString()方法，再转换得到的值

* * * 

* **一元减操作符**

一元减操作符主要用于表示负数。
在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符形同的规则，最后再将得到的数值换换为负数。

### 02 位操作符
ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示整数，1表示负数。这个表示符号的位叫做**符号位**，符号位的值决定了其他数值的格式。

* **正数**

正数以纯二进制格式存储，31位中的每一位都表示2的幂(从后往前位数从小到大)。第一位(叫做位0，在最右面)表示2<sup>0</sup>，第二位表示2<sup>1</sup>,以此类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是0000 0000 0000 0000 0000 0000 0001 0010，或者更简洁的10010.这是5个有效位，这5位本身就决定了实际的值。

* **负数**

负数同样以二进制码存储，但是用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
(1)求这个数值绝对值的二进制码(例如，要求-18的二进制补码，先求18的二进制码)；
(2)求二进制反码，即将0替换为1，将1替换为0；
(3)得到的二进制反码加1

要根据这3个步骤求得-18的二进制码，首先就要求得18的二进制码，即：0000 0000 0000 0000 0000 0000 0001 0010

然后，求其二进制反码，即0和1互换：
1111 1111 1111 1111 1111 1111 1110 1101

最后，二进制反码加1：
1111 1111 1111 1111 1111 1111 1110 1110 

这样，我们就得到的-18的二进制表示。要注意的是，在处理有符号整数时，是不能访问位31的。

ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的值是这个负数绝对值的二进制码前面加上了一个负号。例如下面的例子所示：
```javascript
var num = -18;
alert(num.toString(2)); // "-10010"
```

* 产生的副作用

由于在对数值应用位操作符时，会将64位转成32位，操作完再将结果转换为64位。表面上就像在操作32位数值。这种转换过程所带来的问题是在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。

* 对非数值应用位操作符

如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值(自动完成)，然后再应用位操作符。得到的结果将是一个数值。

#### 001 按位非(NOT)
按位非操作符以一个波浪线(~)表示，执行按位非的结果就是返回数值的反码。
```javascript
var num1 = 25;
var num2 = ~num1;
alert(num2); // -26

var num3 = -25;
var num4 = ~num3;
alert(num4); // 24
```
按位非操作的本质：操作的负值减一

#### 002 按位与(AND)
按位与操作符由一个和字字符(&)表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，然后根据下面的规则，对相同位置上的两个数执行AND操作：

**规则**：当两个数值对应位都是1时返回1，任何一位是0，结果都是0。

#### 003 按位或(OR)
按位或操作符由一个竖线符号(|)表示，同样也有两个操作数。按位或操作符的计算根据下面规则：
**规则**：当两个数值对应位有一个是1时，返回1，只有在两个位都是0的情况下才返回0。

#### 004 按位异或(XOR)
按位异或操作符由一个插入符号(^)表示，也有两个操作数。按位异或操作符的计算根据下面规则：
**规则**： 当两个数值对应位上只有一个1时才返回1，如果对应位上的两位都是1或都是0，则返回0。

#### 005 左移
左移操作符由两个小于号(<<)表示，这个操作符会将数值的所有进位向左移动指定的位数。例如，将数值2(二进制码为10)向左移动5位，结果就是64(二进制码是100 0000)，代码如下所示：
```javascript
var oldValue = 2; //等于二进制的10
var newValue = oldValue << 5; //等于二进制的100 0000，十进制的64
```
* 注意

在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便得到的结果是一个完整的32位二进制数。

* 注意

左移不会影响操作数的符号位。也就是不会影响正负号。

#### 006 有符号的右移
有符号的右移操作符由两个大于号(>>)表示，这个操作符会将数值向右移动，但保留符号位(即正负号标记)。

* 注意

同样的，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。此时ECMAScript会用符号位的值来填充所有空位。

#### 007 无符号右移
无符号右移操作符由3个大于号(>>>)表示，这个操作符会将数值的所有32位都向右移动。

对正数来说，无符号右移的结果与有符号右移相同。

但是对于负数来说，情况就不一样了。
首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当做正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常指大。

### 03 布尔操作符

#### 001 逻辑非

逻辑非操作符由一个叹号(!)表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后对其求反。

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。即同时使用两个逻辑非操作符，当然，最终结果与对这个值使用Boolean()函数相同。

#### 002 逻辑与

逻辑与操作符由两个和号(&&)表示，有两个操作数。

逻辑与操作数可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。

逻辑与操作属于短路操作。它会从左到右依次判断，一旦碰到值为false的，就不再进行之后的操作，返回这个操作数；当所有的值都为真的时候，会返回最后一个真值。

#### 003 逻辑或

逻辑或操作符由两个竖线符号(||)表示，有两个操作数

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。

逻辑或也是短路操作符。它会从左到右依次判断，一旦碰到值为true的，就不再进行之后的操作，返回第一个真值；如果所有的值都为false的时候，会返回最后一个操作数。

* 用处

常用来给变量赋值，避免为变量赋null或undefined值。例如：

```javascript
var myObject = preferredObject || backupObject;
```

### 04 乘性操作符

ECMAScript定义了3个乘性操作符：乘法、除法和求模。

#### 001 乘法

乘法操作符由一个星号(*)表示，用于计算两个数值的乘积。

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

#### 002 除法

除法操作符由一个斜线符号(/)表示，执行第二个操作数除以第一个操作数的计算。

在处理特殊值的情况下，除法操作符遵循下列特殊的规则(部分，详见书)：

* 如果一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

#### 003 求模

求模(余数)操作符由一个百分号(%)表示

在处理特殊值的情况下，求模操作符遵循下列特殊的规则(部分，详见书)：

* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

### 05 加性操作符

#### 001 加法

加法操作符(+)的用法如下所示(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN

* ... ...

* 如果有一个操作数是字符串，就要应用如下规则：

  ①如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来

  ②如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后将两个字符串拼接起来

* 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则

* 对弈undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"

#### 002 减法

减法操作符(-)的用法如下所示(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN
* 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

### 06 关系操作符

关系操作符有：

小于 (<)		大于 (>)		小于等于 (<=)		大于等于 (>=)

这个关系操作符用于对两个值进行比较，结果返回一个布尔值，比较的规则如下：

* ... ...

*  如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
* 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较
* 如果一个操作数是布尔值，则先将其转换为数值，然后执行数值比较
* 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则进行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则进行比较
* 任何操作数与NaN进行关系比较，结果都是false

### 07 相等操作符



