# concept
[TOC]

# 第一章 JavaScript简介

# 第二章 在HTML中使用JavaScript

## 01 文档模式

* 混杂模式
* 标准模式
* 准标准模式

准标准模式和标准模式非常接近，它们的差异几乎可以忽略不计。

一般来说，在提到标准模式时，指的是除混杂模式之外的其他模式。

## 02 noscript元素
noscript是一个元素，该元素能够包含出现在文档body中的任何HTML元素(script元素除外)。

包含在noscript元素中的内容只有在以下情况才会显示出来:
* 浏览器不支持脚本
* 浏览器支持脚本，但脚本被禁用

# 第三章 基本概念

## 01 标识符
标识符就是指变量、函数、属性的名字，或者函数的参数。要求:
* 第一个字符必须是一个字母、下划线或一个美元符号
* 其他字符可以是字母、下划线、美元符号或数字

注意:
* 推荐使用驼峰命名法
* 关键字、保留字、true、false、null不能作为标识符

## 02 注释
单行注释
```javascript
// 单行注释

/* 
*
*
*/
```
多行注释，以/ * 开始，* /结尾，中间的*是为了代码的可读性

## 03 尽量显式地初始化变量
尽量在声明变量的时候进行赋值，尽管未初始化的变量会自动被赋予undefined值。

因为声明但是未初始化的变量或是未声明的变量同时用typeof操作符进行判断都返回undefined，所以，如果我们有良好的习惯(显式的进行声明)，当typeof操作符返回"undefined"，我们就知道被检测的变量没有被声明，而不是尚未初始化。

## 04 null == undefined结果是true
undefined的值是派生自null值的，所以，用==判断，返回true，当然，用===判断，结果返回false

## 05 Number类型
数值字面量格式可以是十进制、八进制或十六进制
* 八进制
第一位必须是0，然后是八进制数字序列(0~7)

如果字面量中的数值超出了范围，那么前导零(第一个0)将被忽略，后面的数值将被当做十进制数值解析。
* 十六进制
前两位必须是0x，后跟任何十六进制数字(0~9及A~F)，字母A~F可以大写，也可以小写

* 注意:
在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

### 001 浮点数值
浮点数值: 该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字

### 002 数值范围
* ECMAScript能表示的最大数值保存在:
**Number.MAX_VALUE**

* ECMAScript能表示的最小数值保存在:
**Number.MIN_VALUE**

* 如果得到一个超出JavaScript数值范围的值，这个数值将被自动转换成特殊的Infinity值(具体来说的话是Infinity和-Infinity)

* Infinity是不能参与计算的，如果你想判断某个数值是不是能够参与计算的，可以使用isFinite()函数，如果结果返回true，表示这个值处于最大值和最小值之间，即可以参与计算

### 003 NaN
* 任何涉及NaN的操作，都会返回NaN
* NaN与任何值都不相等，包括NaN本身
* **isNaN()** 判断某个参数是够能转化成数值
可以接收对象(对于对象，先调用对象的valueOf()方法，然后依照规则转换返回的值。如果转换的结果是NaN，则基于返回值调用对象的toString()方法，然后再次依照规则转换返回的字符串值)。 

### 004 数值转换
有3个函数可以把非数值转换为数值:
* Number()

各种数据类型 → 数值
* parseInt()

字符串 → 整数

忽略字符串前面的空格

如果字符串以"0"开头，后面跟数字字符，将作为八进制数来解析

如果字符串以"0x"开头，后面跟数字字符，将作为十六进制数来解析

接受第2个参数，即转换使用的基数(多少进制)。如果指定了进制，就不用带字符串前面的"0"或"0x"。

* parseFloat()

字符串 → 小数

始终都会忽略前导的0

只解析十进制数，不支持第二个参数指定基数

## 06 String类型
把一个值转换为一个字符串有两种方式:
* toString()

几乎所有值都有这个方法(null和undefined除外)
接受一个参数: 输出数值的基数，如果不传，默认是10进制

* String()

可以将任何类型的值转换为字符串，规则如下:
* 如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果
* 如果值是null，则返回"null"
* 如果值是undefined，则返回"undefined"

## 07 Object
Object的每个实例都具有下列属性和方法。
* constructor：保存着哦用于创建当前对象的函数
* hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中(而不是再实例的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定
* isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型
* propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
* toLocaleString()：放回对象的字符串表示，该字符串与执行环境的地区对应。
* toString()：放回对象的字符串表示。
* valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

## 08 操作符
包括：
* 算数操作符
* 位操作符
* 关系操作符
* 相等操作符

### 01 一元操作符
#### 001 递增和递减操作符
前置递增和递减操作时，变量的值都是在语句被求值之前改变的(也就是先执行递增/递减操作，再运算)

后置递增和递减操作时，变量的值都是在包含它们的语句被求值之后才执行的(也就是先运算，再执行递增/递减操作)

这四个操作符对任何值都适用，即整数、字符串、布尔值、浮点数、对象。遵从以下规则：
* 在应用于一个包含有效数字字符的字符串时，先将其转换成数字值，再执行加减1的操作。字符串变量变成数值变量。
* 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变为数值变量。
* 在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变为数值变量。
* 在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变为数值变量。
* 在应用于浮点数值时，执行加减1的操作。
* 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

#### 002 一元加和减操作符
* **一元加操作符**

在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值进行转换，即：
* 布尔值的false和true将被转换为0和1
* 字符串值会被按照一组特殊的规则进行解析
* 对象先是调用它们的valueOf()和(或)toString()方法，再转换得到的值

* * * 

* **一元减操作符**

一元减操作符主要用于表示负数。
在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符形同的规则，最后再将得到的数值换换为负数。

### 02 位操作符
ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示整数，1表示负数。这个表示符号的位叫做**符号位**，符号位的值决定了其他数值的格式。

* **正数**

正数以纯二进制格式存储，31位中的每一位都表示2的幂(从后往前位数从小到大)。第一位(叫做位0，在最右面)表示2<sup>0</sup>，第二位表示2<sup>1</sup>,以此类推。没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是0000 0000 0000 0000 0000 0000 0001 0010，或者更简洁的10010.这是5个有效位，这5位本身就决定了实际的值。

* **负数**

负数同样以二进制码存储，但是用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
(1)求这个数值绝对值的二进制码(例如，要求-18的二进制补码，先求18的二进制码)；
(2)求二进制反码，即将0替换为1，将1替换为0；
(3)得到的二进制反码加1

要根据这3个步骤求得-18的二进制码，首先就要求得18的二进制码，即：0000 0000 0000 0000 0000 0000 0001 0010

然后，求其二进制反码，即0和1互换：
1111 1111 1111 1111 1111 1111 1110 1101

最后，二进制反码加1：
1111 1111 1111 1111 1111 1111 1110 1110 

这样，我们就得到的-18的二进制表示。要注意的是，在处理有符号整数时，是不能访问位31的。

ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，我们看到的值是这个负数绝对值的二进制码前面加上了一个负号。例如下面的例子所示：
```javascript
var num = -18;
alert(num.toString(2)); // "-10010"
```

* 产生的副作用

由于在对数值应用位操作符时，会将64位转成32位，操作完再将结果转换为64位。表面上就像在操作32位数值。这种转换过程所带来的问题是在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。

* 对非数值应用位操作符

如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值(自动完成)，然后再应用位操作符。得到的结果将是一个数值。

#### 001 按位非(NOT)
按位非操作符以一个波浪线(~)表示，执行按位非的结果就是返回数值的反码。
```javascript
var num1 = 25;
var num2 = ~num1;
alert(num2); // -26

var num3 = -25;
var num4 = ~num3;
alert(num4); // 24
```
按位非操作的本质：操作的负值减一

#### 002 按位与(AND)
按位与操作符由一个和字字符(&)表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，然后根据下面的规则，对相同位置上的两个数执行AND操作：

**规则**：当两个数值对应位都是1时返回1，任何一位是0，结果都是0。

#### 003 按位或(OR)
按位或操作符由一个竖线符号(|)表示，同样也有两个操作数。按位或操作符的计算根据下面规则：
**规则**：当两个数值对应位有一个是1时，返回1，只有在两个位都是0的情况下才返回0。

#### 004 按位异或(XOR)
按位异或操作符由一个插入符号(^)表示，也有两个操作数。按位异或操作符的计算根据下面规则：
**规则**： 当两个数值对应位上只有一个1时才返回1，如果对应位上的两位都是1或都是0，则返回0。

#### 005 左移
左移操作符由两个小于号(<<)表示，这个操作符会将数值的所有进位向左移动指定的位数。例如，将数值2(二进制码为10)向左移动5位，结果就是64(二进制码是100 0000)，代码如下所示：
```javascript
var oldValue = 2; //等于二进制的10
var newValue = oldValue << 5; //等于二进制的100 0000，十进制的64
```
* 注意

在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便得到的结果是一个完整的32位二进制数。

* 注意

左移不会影响操作数的符号位。也就是不会影响正负号。

#### 006 有符号的右移
有符号的右移操作符由两个大于号(>>)表示，这个操作符会将数值向右移动，但保留符号位(即正负号标记)。

* 注意

同样的，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。此时ECMAScript会用符号位的值来填充所有空位。

#### 007 无符号右移
无符号右移操作符由3个大于号(>>>)表示，这个操作符会将数值的所有32位都向右移动。

对正数来说，无符号右移的结果与有符号右移相同。

但是对于负数来说，情况就不一样了。
首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当做正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常指大。

### 03 布尔操作符

#### 001 逻辑非

逻辑非操作符由一个叹号(!)表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后对其求反。

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。即同时使用两个逻辑非操作符，当然，最终结果与对这个值使用Boolean()函数相同。

#### 002 逻辑与

逻辑与操作符由两个和号(&&)表示，有两个操作数。

逻辑与操作数可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。

逻辑与操作属于短路操作。它会从左到右依次判断，一旦碰到值为false的，就不再进行之后的操作，返回这个操作数；当所有的值都为真的时候，会返回最后一个真值。

#### 003 逻辑或

逻辑或操作符由两个竖线符号(||)表示，有两个操作数

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。

逻辑或也是短路操作符。它会从左到右依次判断，一旦碰到值为true的，就不再进行之后的操作，返回第一个真值；如果所有的值都为false的时候，会返回最后一个操作数。

* 用处

常用来给变量赋值，避免为变量赋null或undefined值。例如：

```javascript
var myObject = preferredObject || backupObject;
```

### 04 乘性操作符

ECMAScript定义了3个乘性操作符：乘法、除法和求模。

#### 001 乘法

乘法操作符由一个星号(*)表示，用于计算两个数值的乘积。

在处理特殊值的情况下，乘法操作符遵循下列特殊的规则(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

#### 002 除法

除法操作符由一个斜线符号(/)表示，执行第二个操作数除以第一个操作数的计算。

在处理特殊值的情况下，除法操作符遵循下列特殊的规则(部分，详见书)：

* 如果一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

#### 003 求模

求模(余数)操作符由一个百分号(%)表示

在处理特殊值的情况下，求模操作符遵循下列特殊的规则(部分，详见书)：

* ... ...
* 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则

### 05 加性操作符

#### 001 加法

加法操作符(+)的用法如下所示(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN

* ... ...

* 如果有一个操作数是字符串，就要应用如下规则：

  ①如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来

  ②如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后将两个字符串拼接起来

* 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则

* 对弈undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"

#### 002 减法

减法操作符(-)的用法如下所示(部分，详见书)：

* 如果有一个操作数是NaN，则结果是NaN
* ... ...
* 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN
* 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

### 06 关系操作符

关系操作符有：

小于 (<)		大于 (>)		小于等于 (<=)		大于等于 (>=)

这个关系操作符用于对两个值进行比较，结果返回一个布尔值，比较的规则如下：

* ... ...

*  如果两个操作数都是字符串，则比较两个字符串对应的字符编码值
* 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较
* 如果一个操作数是布尔值，则先将其转换为数值，然后执行数值比较
* 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则进行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则进行比较
* 任何操作数与NaN进行关系比较，结果都是false

### 07 相等操作符

#### 001 相等和不相等

相等操作符由两个等于号(==)表示，如果两个操作数相等，则返回true。

不相等操作符由叹号后跟等于号(!=)表示，如果两个操作数不相等，则返回true。

这两个操作符都会先转换操作数(通常称为强制转型)，然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

* 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，true转换为1
* 如果有一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值
* 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较

这两个操作符在进行比较时则要遵循下列规则：

* nullheundefined是相等的
* 要比较相等性之前，不能将null和undefined转换成其他任何值
* 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。
* 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

#### 002 全等和不全等

全等操作符由3个等于号(===)表示，如果两个操作数相等，则返回true。

不全等操作符由叹号后跟两个等于号(!==)表示，如果两个操作数不相等，则返回true。

这两个操作数都不会先转换数据类型，而是直接比较两个操作数的相等性。

* 记住

null == undefined会返回true，因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。

* 注意

由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。

### 08 条件操作符

条件操作符就是指三元运算符：

xx ? yy : zz       

如果xx为true，就取值yy，如果xx为false，就取值zz

### 09 赋值操作符

简单的赋值操作符由等于号(=)表示，其作用就是把右侧的值赋给左侧的变量。

如果在等于号(=)前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。

每个主要算术运算符(以及个别的其他操作符)都有对应的复合赋值操作符。这些操作符如下所示：

* 乘/赋值 ( *= )
* 除/赋值 ( /= )
* 模/赋值 ( %= )
* 加/赋值 ( += )
* 减/赋值 ( -= ) 
* 左移/赋值 ( <<= )
* 有符号右移/赋值 ( >>= )
* 无符号右移/赋值 ( >>>= )

设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

### 10 逗号运算符

使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：

```javascript
var num1 = 1, num2 = 2, num3 = 3;
```

逗号操作符多用于声明多个变量，但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：

```javascript
var num = (5, 1, 4, 8, 0); // num的值为0
```

由于0是表达式中的最后一项，因此num的值就是0。虽然逗号的这种使用方式并不常见，但这个例子可以绑我们理解逗号的这种行为。

## 09 语句

### 01 if语句

大多数编程语言中最为常用的一个语句就是if语句。以下是if语句的语法：

```javascript
if (condition) statement1 else statement2
```

其中的condition(条件)可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果是true，则执行statement1(语句1)，如果对condition求值的结果是false，则执行statement2(语句2)。而且这两个语句既可以是一行代码，也可以是一个代码块(以一对花括号括起来的多行代码)。

请看下面的例子

```javascript
if (i > 25 )
    alert ("Greater than 25."); // 单行语句
else {
    alert ("Less than or equal to 25."); // 代码块中的语句
}
```

不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。

### 02 do-while语句

do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是do-while语句的语法：

```javascript
do {
    statement
} while (expression);
```

* 注意

像do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。

### 03 while语句

while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会执行。以下是while语句的语法：

```javascript
while (expression) statement
```

### 04 for语句

for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是for语句的语法：

```javascript
for (initialization; expression; post-loop-expression) statement
// 初始化表达式 控制表达式 循环后表达式
```

使用while循环做不到的，使用for循环同样也做不到。也就是说，for循环值是把与循环有关的代码集中到了一个位置。

有必要指出的是，在for循环的变量初始化表达式中，也可以不使用var关键字。该变量的初始化可以放在外部执行。

此外，for语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式省略，就会创建一个无限循环，例如： 

```javascript
for ( ; ; ) { // 无限循环
    doSomething();
}
```

而只给出控制表达式实际上就把for循环转换成了whild循环，例如：

```javascript
var count = 10;
var i = 0;
for ( ; i < count; ){
    alert(i);
    i++;
}
```

由于for语句存在极大的灵活性，因此它也是ECMAScript中最常用的一个语句。

### 05 for-in语句

for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是for-in语句的语法：

for ( property in expression ) statement

下面是一个示例：

```javascript
for (var propName in window) {
    document.write(propName);
}
```

在这个例子中，我们使用for-in循环来显示了BOM中window对象的所有属性。每次执行循环时，都会将window对象中存在的一个属性名赋值给变量propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与for语句类似，这里控制语句中的var操作符也不是必须的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。

ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会 因浏览器而异。

但是，如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。ECMAScript5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

### 06 label语句

使用label语句可以在代码中添加标签，以便将来使用。以下是label语句的用法：

```javascript
label: statement
```

下面是一个示例：

```javascript
start: for (var i=0; i < count; i++) {
    alert(i);
}
```

这个例子中定义的start标签可以在将来由break或continue语句引用。加标签的语句一般都要与for语句等循环语句配合使用。

### 07 break和continue语句

break和continue语句用于在循环中精确地控制代码的执行。其中，break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。

break和continue语句都可以与label语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示：

```javascript
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            break outermost;
        }
        num++;
    }
}
alert(num); // 55
```

break语句带了一个参数：要返回到的标签。添加这个标签的结果将导致break语句不仅会退出内部的for语句(即使用变量j的循环)，而且也会退出外部的for语句(即使用变量i的循环)。为此。当变量i和j都等于5时，num的值正好是55.同样，continue语句也可以像这样与label语句联用，如下面的例子所示：

```javascript
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
            continue outermost;
        }
        num++;
    }
}
alert(num); // 95
```

在这种情况下，continue语句会强制继续执行循环——退出内部循环，执行外部循环。当j是5时，continue语句执行，而这也意味着内部循环少执行了5次，因此num的结果是95。

虽然联用break、continue和label语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用label语句，一定要使用描述性的标签，同时不要嵌套过多的循环。

### 08 with语句

with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下：

```javascript
with (expression) statement;
```

定义with语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：

```javascript
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
```

上面几行代码都包含location对象。如果使用with语句，可以把上面的代码改写成如下所示：

```javascript
with(location) {
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
```

在这个重写后的例子中，使用with语句关联了location对象。这意味着在with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。

严格模式下不允许使用with语句，否则将视为语法错误。

* 注意

由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### 09 switch语句

switch语句与if语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript中switch语句的语法与其他基于C的语言非常接近，如下所示：

```javascript
switch (expression) {
    case value: statement
      break;
    case value: statement
      break;
    case value: statement
      break;
    case value: statement
      break;
    default: statement
}
```

switch语句中的每一种情形(case)的含义是："如果表达式等于这个值(value)，则执行后面的语句(statement)"。而break关键字会导致执行流跳出switch语句。如果省略break关键字，就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码(因此，也相当于一个else语句)。

虽然ECMAScript中的switch语句借鉴自其它语言，但这个语句也有自己的特色。首先，可以在switch语句中使用任何数据类型(在很多其它语言中只能使用数值)，无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。

* 注意

switch语句在比较值时使用的是全等操作符，因此不会发生类型转换(例如，字符串"10"不等于数值10)。

## 10 函数

函数对于任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。函数的基本语法如下所示：

```javascript
function functionName(arg0, arg1, ...argN) {
    statements
}
```

这个函数可以通过其函数名来调用，后面还要加上一对圆括号和参数(圆括号中的参数如果有多个，可以用逗号隔开)。

ECMAScript中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值。

位于return语句之后的任何代码都永远不会执行。

另外，return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。

严格模式对函数有一些限制：

* 不能把函数命名为eval 或 arguments
* 不能把参数命名为eval 或 arguments
* 不能出现两个命名参数同名的情况

如果发生以上情况，就会导致语法错误，代码无法执行

### 01 理解参数

ECMAScript函数的参数与大多数其他语言中的函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。

之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数( 如果有参数的话 )。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。

其实，arguments对象只是与数组类似( 它并不是Array的实例，而是一个伪数组 )，因为可以使用方括号语法访问它的每个元素( 即第一个元素是arguments[0]，第二个元素是arguments[1]，以此类推 )，使用length属性来确定传递进来多少个参数。

arguments对象可以与命名参数( 即指形式参数 )一起使用。

还有一点，arguments的值永远与对应命名参数的值保持同步。例如：

```javascript
function doAdd (num1,num2) {
    argument[1] = 10;
    console.log(num2);
}

// doAdd(1,2); // 10 "num2"
// doAdd(1); // undefined "num2"
```

每次执行这个doAdd()函数都会重写第二个参数，将第二个参数的值修改为10。因为arguments对象中的值会自动反映到对应的命名参数，所以修改argument[1]，也就修改了num2，结果它们的值都会变成10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。另外还要记住，如果只传入了一个参数，那么为arguments[1]设置的值不会反映到命名参数中。这是因为arguments对象的长度是由传入参数的个数决定的，不是由定义函数时的命名参数的个数决定的。

关于采纳数还要记住最后一点：没有传递的命名参数将被自动被赋予undefined值。这也正是为什么上面例子中只传递一个参数，num2的值是undefined了。

严格模式对于如何使用arguments对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把arguments[1]设置为10，num2的值仍然还是undefined。其次，重写arguments的值会导致语法错误(代码将不会执行)。

### 02 没有重载

ECMAScript函数不能像传统意义上那样实现重载。而在其他语言(如Java)中，可以为一个函数编写两个定义，只要这两个定义的签名(接受的参数的类型和数量)不同即可。如前所述，ECMAScript函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。

如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。

# 第四章 变量、作用域和内存问题

## 01 基本类型和引用类型的值

**基本类型值**指的是简单的数据段。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

**引用类型值**指那些可能由多个值构成的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，可能操作的是对象的引用(当复制保存着对象的某个变量时，操作的是对象的引用；但在为对象添加属性时，操作的是实际的对象)。

### 001 动态的属性

对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name); // "Nicholas"
```



但是，我们不能给基本类型的值添加属性，尽管这样不会导致任何错误。

```javascript
var name = "Nicholas";
name.age = 27;
alert(name.age); // undefined
```

这说明只能给引用类型值动态地添加属性，以便将来使用。

 ### 002 复制变量值

在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。

如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。

```javascript
var num1 = 5;
var num2 = num1;
```

在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5。但num2中的5与num1中的5是完全独立的，该值值是num1中5的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。

复制前的变量对象：

|      |                |
| ---- | -------------- |
|      |                |
| num1 | 5 (Number类型) |

复制后的变量对象：

|      |                |
| ---- | -------------- |
| num2 | 5 (Number类型) |
| num1 | 5 (Number类型) |

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name); // "Nicholas"
```

首先，变量obj1保存了一个对象新的实例。然后，这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。

### 003 传递参数

ECMAScript中所有函数的参数都是**按值传递**的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素)。

在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。看下面这个例子：

```javascript
function addTen(num) {
    num += 10;
    return num;
}
var count = 20;
var result = addTen(count);
alert(count); // 20，没有变化
alert(result); // 30
```

这里的函数addTen()有一个参数num，而参数实际上是函数的**局部变量**。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20。于是，数值20被复制给参数num以便在addTen()中使用。在函数内部，参数num的值被加上了10，但这一变化不会影响函数外部的count变量。参数num和count互不认识，它们仅仅是具有相同的值。加入num是按引用传递的话，那么变量count的值也将变成30，从而反映函数内部的修改。当然，使用数值等基本类型的值来说明按值传递参数比较简单，但如果使用对象，那问题就不怎么好理解了。再举一个例子：

```javascript
function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name); // "Nicholas"
```

以上代码中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有所反映；因为person指向的对象在堆内存中只有一个，而且是全局对象。有许多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：

```javascript
function setName() {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); // "Nicholas"
```

这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后，其name属性被设置为"Nicholas"。然后，又将一个新对象赋给变量obj，同时将其name属性设置为"Greg"。如果person是按引用传递的，那么person就会被自动修改为指向其name属性值为“Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是"Nicholas"。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。

* 注意

可以把ECMAScript函数的参数想象成局部变量。

### 004 检测类型

要检测一个变量是不是基本数据类型。使用typeof操作符是最佳的工具。说得更具体点，typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。如果变量的值是一个对象或null，则typeof操作符会像下面例子中所示的那样返回"object"。

虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用数据类型的值时，这个操作符的用处不大。通常，我们并不想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符，其语法如下所示：

```javascript
result = variable instanceof constructor
```

如果变量是给定引用类型(根据它的原型链来识别)的实例，那么instanceof操作符就会返回true。请看下面的例子。

根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof擦偶偶福始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。

```javascript
var a1 = 1;
    var a2 = "233";
    var a3 = false;
    var a4 = undefined;
    var a5 = null;

    var a6 = {
        name: 'jack'
    };
    var a7 = [1,2,3];
    var a8 = function () {
        console.log('test');
    };
    var a9 = /^3/;

    console.log(typeof a1,'typeof a1'); // number
    console.log(typeof a2,'typeof a2'); // string
    console.log(typeof a3,'typeof a3'); // boolean
    console.log(typeof a4,'typeof a4'); // undefined
    console.log(typeof a5,'typeof a5'); // object
    console.log(typeof a6,'typeof a6'); // object
    console.log(typeof a7,'typeof a7'); // object
    console.log(typeof a8,'typeof a8'); // function
    console.log(typeof a9,'typeof a9'); // object

    console.log(a6 instanceof Object,'a6 instanceof Object'); // true
    console.log(a7 instanceof Object,'a7 instanceof Object'); // true
    console.log(a8 instanceof Object,'a8 instanceof Object'); // true
    console.log(a9 instanceof Object,'a9 instanceof Object'); // true

    console.log(a7 instanceof Array,'a7 instanceof Array'); // true
    console.log(a8 instanceof Function,'a8 instance Function'); // true
    console.log(a9 instanceof RegExp,'a9 instance RegExp'); // true
```

